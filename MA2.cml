process MA2 = id_ : token @
begin

values
endtime : real = 1
stepSize : real = 0.5
state 
de_fmu_level : real := 0.0
de_fmu_valRef_set : valueReference := 2
de_fmu_valRef_get : valueReference := 1
de_fmu_valve : bool := false
CCP : real := 0.0
id : token := id_

operations
tempUpdateVariables: () ==> ()
tempUpdateVariables() == 
(
	if de_fmu_valve then de_fmu_level := de_fmu_level - 0.4 else de_fmu_level := de_fmu_level + 0.4 
)

actions
set_de_input = fmi2SetReal ! id ! de_fmu_valRef_set ! de_fmu_level -> set_de_status
set_de_status = fmi2StatusReturn ? st -> Skip

get_de_output = fmi2GetBoolean ! id ! de_fmu_valRef_get -> get_de_status_bool
get_de_status_bool = fmi2GetBooleanReturn ? value ? status -> de_fmu_valve := value

dostep = fmi2DoStep ! id ! CCP ! stepSize -> doStepStatus
doStepStatus = fmi2StatusReturn ? st -> Skip

terminate = fmi2Terminate ! id -> Skip
 

cycle = 
	get_de_output; 
	
	set_de_input; 
	
	tempUpdateVariables(); 
	
	if CCP + stepSize <= endtime 
	then 
	(
		dostep;
		CCP:=CCP+stepSize;
		cycle
	) 
	else terminate

@ cycle

end