process FMU_Proc = id_ : token @
begin
types

values 

state
	fmu : [AFMU] := nil
	id : token := id_
	io : [IO] := nil
	
actions
	-- NOTE: Pattern matching tuples does not work

	ReturnStatus = s : fmi2Status @ fmi2StatusReturn ! s -> Skip
	
	Instantiate = fmi2Instantiate ! id -> 
	(
		dcl x : Instantiator @ 
		x := new Instantiator();
		fmu := x.instantiate(id);
		ReturnStatus(<fmi2OK>)
	)
	
	EnterInitMode = fmi2EnterInitializationMode ! id -> 
		let s = fmu.EnterInitializationMode() in 
			ReturnStatus(s)
	
	ExitInitMode = fmi2ExitInitializationMode ! id -> 
		let s = fmu.ExitInitializationMode() in
			ReturnStatus(s)
	
	SetReal = 
		fmi2SetReal ! id ? x ? y -> 
		(
			let s = fmu.setInputReal(x,y) in
			(
				ReturnStatus(s)
			)
		)
		
	GetBoolean = 
		fmi2GetBoolean ! id ? x ->
		(
			let r : booleanReturn = fmu.getBoolean(x) in
			(
				fmi2GetBooleanReturn ! (r.#1) ! (r.#2) -> Skip
			)
		)
		
	SetBoolean = 
		fmi2SetBoolean ! id ? x ? y ->		
			let s : fmi2Status = fmu.setInputBoolean(x,y) in			
				ReturnStatus(s)
			
		
		
	GetReal = 
		fmi2GetReal ! id ? x ->		
			let r : realReturn = fmu.getReal(x) in			
				fmi2GetRealReturn ! (r.#1) ! (r.#2) -> Skip
			
		
	DoStep = 
		fmi2DoStep ! id ? ccp ? ss ->		
			let s : fmi2Status = fmu.doStep(ccp, ss) in			
				ReturnStatus(s)		
		
	Terminate = fmi2Terminate ! id -> Skip
	
	SimulationLoop = (SetBoolean [] GetBoolean [] GetReal [] SetReal [] DoStep);SimulationLoop [] Terminate
	
@ Instantiate; (Terminate [] EnterInitMode);(Terminate [] ExitInitMode);SimulationLoop

end