class FMU_CT extends AFMU = 
begin

state
valveControl : bool := false
level : real := 0.0
doStepCalc : [DoStepCalculator] := nil 
period : real := 0.5
io : [IO] := nil

operations
	public FMU_CT:() ==> FMU_CT
	FMU_CT() == 
	(
		doStepCalc := new DoStepCalculator(period);
		io := new IO()
	)
	
	public setInputBoolean: valueReference * bool ==> fmi2Status
	setInputBoolean(vRef,v) == 
		if vRef = 1 
		then 
		(
			valveControl := v;
			return <fmi2OK>
		) 
		else 
			return <fmi2Error>
	
	public getReal : valueReference ==> realReturn
	getReal(vRef) == 
		(
			let x = io.echo("ct - getReal0") in		
			if vRef = 2 
			then 
			(
				let x = io.echo("ct - getReal1") in
					return mk_(level,<fmi2OK>)
			)
			else
			(
				let x = io.echo("ct - getReal2") in
					return mk_(level,<fmi2Error>)
			)
		)
	
	public doStep : currentCommunicationPoint * communicationStepSize ==> fmi2Status
	doStep(t, h) == 
		if doStepCalc.isCcpValid(t)
		 then 
		 (
		 	let steps: int = doStepCalc.calcDoSteps(t,h) in
		 	(
		 		controlLogic(steps);
			 	return <fmi2OK>
		 	)
		 )
		 else return <fmi2Error>
	
	private controlLogic: int ==> ()
	controlLogic(steps) == 
		for i = 1 to steps do
			if valveControl
			then 
				level := level - 0.4 
			else 
				level := level + 0.4 

end