class AFMU = 
begin

types
	FMIState = <Instantiated> | <InitializationMode> | <SlaveInitialized>

state
	io : [IO] := nil
	protected fmuState : [FMIState] := nil


operations
	public AFMU: () ==> AFMU
	AFMU() == (io := new IO())
	
	public getState : () ==> FMIState
	getState() == return fmuState
	
	public Instantiate : () ==> fmi2Status
	Instantiate() == 
	(
		if(fmuState = nil)
		then
		(
			fmuState := <Instantiated>; 
			return <fmi2OK>
		)
		else return <fmi2Error>
	)
	
	public EnterInitializationMode : () ==> fmi2Status
	EnterInitializationMode() == 
	(
		if fmuState = <Instantiated> 
		then (fmuState := <InitializationMode>; return <fmi2OK>)
		else return <fmi2Error>
	)
	
	public ExitInitializationMode : () ==> fmi2Status
	ExitInitializationMode() == 
	(
		if fmuState = <InitializationMode> 
		then (fmuState := <SlaveInitialized>; return <fmi2OK>)
		else return <fmi2Error>
	)
	
	public setInputBoolean: valueReference * bool ==> fmi2Status
	setInputBoolean(vRef,v) == let x = io.echo("FMUInterface") in return <fmi2Error>
	
	public setInputReal: valueReference * real ==> fmi2Status
	setInputReal(vRef,v) == let x = io.echo("FMUInterface") in return <fmi2Error>
	
	public setInputInteger: valueReference * int ==> fmi2Status
	setInputInteger(vRef,v) == let x = io.echo("FMUInterface") in return <fmi2Error>

	public getReal : valueReference ==> (real * fmi2Status)
	getReal(vRef) == let x = io.echo("FMUInterface") in return mk_(0.0, <fmi2Error>)
	
	public getBoolean : valueReference ==> booleanReturn
	getBoolean(vRef) == let x = io.echo("FMUInterface") in return mk_(false, <fmi2Error>)
	
	public getInteger : valueReference ==> (int * fmi2Status)
	getInteger(vRef) == let x = io.echo("FMUInterface") in return mk_(0, <fmi2Error>)
	
	public doStep : currentCommunicationPoint * communicationStepSize ==> fmi2Status
	doStep(t, h) == let x = io.echo("FMUInterface") in return <fmi2Error>

end