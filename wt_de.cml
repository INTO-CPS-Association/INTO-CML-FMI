values
	ID_wt_de = mk_token("wt_de")
	ID_wt_de_set = {ID_wt_de}

-- Is there a better way of doing this?	
chansets
	wt_de_setReal = {|fmi2SetReal.x | x in set ID_wt_de_set|}
	wt_de_getBoolean = {|fmi2GetBoolean|}
	wt_de_doStep = {|fmi2DoStep.x | x in set ID_wt_de_set|}
	wt_de_setupExp = {|fmi2SetupExperiment.x | x in set ID_wt_de_set|}
	wt_de_enterInit = {|fmi2EnterInitializationMode.x | x in set ID_wt_de_set|}
	wt_de_ExitInit = {|fmi2ExitInitializatoinMode.x | x in set ID_wt_de_set|}
	wt_de_Terminate = {|fmi2Terminate.x | x in set ID_wt_de_set|}
	wt_de_chansets = wt_de_setReal union
		wt_de_getBoolean union 
		wt_de_doStep union 
		wt_de_setupExp union 
		wt_de_enterInit union
		wt_de_ExitInit union
		wt_de_Terminate

process wt_de = 
begin

values
minLevel : real = 1.0
maxLevel : real = 2.0
period : real = 0.05

state
level : real := 0.0
valve : bool := true
doStepCalc : [DoStepCalculator] := nil 
canBeInvoked2 : bool := true

operations
initObject:() ==>()
initObject () == 
(
	doStepCalc := new DoStepCalculator(period)
)


private canBeInvoked : real ==> bool
canBeInvoked(ccp) == doStepCalc.canBeInvokedExt(ccp)

actions
	Initialization = doStepCalc := new DoStepCalculator(period)
	SetReal = fmi2SetReal?x?y?z!(if y = 2 then <fmi2OK> else <fmi2Error>) -> if y = 2 then level := z else Skip
	GetBoolean = fmi2GetBoolean . ID_wt_de ! valve ! <fmi2OK> ? x -> Skip
	           [] fmi2GetBoolean . ID_wt_de ! false ! <fmi2Error> ? x -> Skip		
	ControlLogic = count : int @  
		if count > 0 
		then 
			if level > maxLevel
			then
				valve := true
			elseif level < minLevel
			then
				valve := false
			else
				Skip 
		else Skip
	DoStep = fmi2DoStep?x?ccp?ss!( 
		let invokeOK = doStepCalc.canBeInvokedExt(ccp) in if invokeOK then <fmi2OK> else <fmi2Error>) 
		->  if doStepCalc.canBeInvokedExt(ccp) 
			then 
			(
				dcl doSteps : int @ doSteps := doStepCalc.CalcDoSteps(ccp,ss);
				ControlLogic(doSteps)
			)
			else
				Skip
	StopSim = fmi2Terminate?x -> Stop
	SimulationLoop = (StopSim [] GetBoolean); (SetReal [] StopSim); (StopSim [] DoStep); SimulationLoop
	
@ SimulationLoop

end