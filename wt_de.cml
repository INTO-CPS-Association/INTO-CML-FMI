values
	ID_wt_de = mk_token("wt_de")
	ID_wt_de_set = {ID_wt_de}

-- Is there a better way of doing this?	
chansets
	wt_de_setReal = {|fmi2SetReal.x | x in set ID_wt_de_set|}
	wt_de_getBoolean = {|fmi2GetBoolean|}
	wt_de_doStep = {|fmi2DoStep.x | x in set ID_wt_de_set|}
	wt_de_setupExp = {|fmi2SetupExperiment.x | x in set ID_wt_de_set|}
	wt_de_enterInit = {|fmi2EnterInitializationMode.x | x in set ID_wt_de_set|}
	wt_de_ExitInit = {|fmi2ExitInitializatoinMode.x | x in set ID_wt_de_set|}
	wt_de_Terminate = {|fmi2Terminate.x | x in set ID_wt_de_set|}
	wt_de_chansets = wt_de_setReal union
		wt_de_getBoolean union 
		wt_de_doStep union 
		wt_de_setupExp union 
		wt_de_enterInit union
		wt_de_ExitInit union
		wt_de_Terminate union
		{|fmi2GetBooleanReturn|} union
		{|fmi2StatusReturn|}

process wt_de = 
begin

values
minLevel : real = 1.0
maxLevel : real = 2.0
period : real = 0.5

state
level : real := 0.0
valve : bool := true
doStepCalc : [DoStepCalculator] := nil 
canBeInvoked2 : bool := true
stopSim : bool := false

operations
initObject:() ==>()
initObject () == 
(
	doStepCalc := new DoStepCalculator(period)
)


private canBeInvoked : real ==> bool
canBeInvoked(ccp) == doStepCalc.canBeInvokedExt(ccp)

actions
	Initialization = doStepCalc := new DoStepCalculator(period)
	SetReal = 
		fmi2SetReal ! ID_wt_de ? y ? z -> 
			if y = 2 
			then 
			(
				level := z;
				fmi2StatusReturn!<fmi2OK> -> Skip
			) 
			else 
				fmi2StatusReturn!<fmi2Error> -> Skip
	GetBoolean = 
		fmi2GetBoolean ! ID_wt_de ? valRef ->
			if valRef = 1 
			then 
				fmi2GetBooleanReturn ! valve ! <fmi2OK> -> Skip
		else
			fmi2GetBooleanReturn ! false ! <fmi2Error> -> Skip
	ControlLogic = count : int @  
		if count > 0 
		then 
			if level > maxLevel
			then
				valve := true
			else 
				valve := false
		else Skip
	DoStep = fmi2DoStep ! ID_wt_de ? ccp ? ss ->
		 if doStepCalc.canBeInvokedExt(ccp)
		 then 
		 (
		 	dcl doSteps : int @ doSteps := doStepCalc.CalcDoSteps(ccp,ss);
			ControlLogic(doSteps);
		 	fmi2StatusReturn ! <fmi2OK> -> GetBoolean
		 )
		 else fmi2StatusReturn ! <fmi2Error> -> GetBoolean
	Terminate = fmi2Terminate ! ID_wt_de -> Skip
	
	// TODO: Should the FMU offer everything always?
	SimulationLoop = (GetBoolean;SimulationLoop) [] (SetReal;SimulationLoop) [] (DoStep;SimulationLoop) [] (Terminate;Skip)
	
@ Initialization; SimulationLoop

end